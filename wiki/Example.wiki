#summary An example of how to run JAFFA

= Introduction =

To help get you started, here, we provide a small demo of how to run JAFFA.

We will use the first 1 million read pairs from the BTF-7 (SRA accession: SRR925695)
and MCF-7 (SRA accession: SRR925723) RNA-Seq datasets. You can download this demo dataset from [address here]. The reads are 76bp paired end, which means we can show all three modes of JAFFA: assembly, direct and hybrid.

Before you start, place all the downloaded files into the same directory. I'll refer to this directory like so `<data dir>` in the example. The directory with the JAFFA package, will be refered to as `<JAFFA dir>`.
Now, create the directory where you want the JAFFA output file to be written, and change into this directory.

= JAFFA - assembly =

We will start by demonstrating the assembly mode. Type the following on the command line:
{{{
bpipe run -p read_length=76 <JAFFA dir>/JAFFA.groovy <data dir>/BT-474_small_*.fastq.gz <data dir>/MCF-7_small_*.fastq.gz
}}}
Or, if you only have the demo files in <data dir>, you can just type:
{{{
bpipe run -p read_length=76 <JAFFA dir>/JAFFA.groovy <data dir>/*
}}}


Bpipe will giving you information about each stage in the pipeline as it run it. Let go through these in some detail.
  # *_Stage run_check_* - This checks that all the required software is installed. If bpipe fails here, you may need to double check the installation.
  # *Stage _make_dir_using_fastq_names_* - Next bpipe with create two branchs, one for each sample set. In the case of this demo, there will be one for MCF-7 and one for BTF-7. These branches will be run in parrallel. You can control the number of branches running in parallel with the bpipe `-n` option.
     # *_Stage prepare_reads_* Now you will see that bpipe is running Trimmomatic. With JAFFA's default setting, no trimming is actually performed, but the fastq files will be unzipped. It is possible to control the amount of trimming. See`JAFFA_stages.groovy`.
    # *_Stage run_assembly_*. Next the reads will be assembled. This stage may take a while.. go and have a cup of tea. The assembly involved running velveth, velvetg then oases, 6 times: once for each kmer 19, 23, 27,31 and 35, and these once to merge. If something goes wrong with the pipeline, it is often during this stage. For example you will need to ensure that your machine has enough RAM (especially if you are running samples in parallel). The assembly can be adjusted in the JAFFA script `assemble.sh`
    # _*Stage align_transcripts_to_annotation_*. The assembled contigs will then be aligned to the reference transcriptome (GENCODE by default). BLAT is used for this.
    # _*Stage filter_transcripts_*. Preliminary filtering will be performed (this uses an R script).
    # _*Stage extract_fusion_sequences_*. The fasta sequences of the preliminary candidate will be extracted
    # _*Stage map_reads*_. Reads are mapped back to the candidate fusion sequences
    #_*Stage get_spanning_reads*_. JAFFA will count the number of spanning read and spanning pairs over the break point of the fusions
    # _*Stage align_transcripts_to_genome*_. The candidates will be aligned to the human genome using BLAT
    # _*Stage get_final_list*_. A second filtering of the candidates is done using the genomic alignment and read coverage data. A file ending in `.summary` will contain all the candidates fusions identified by JAFFA
  #_*Stage compile_all_results*_. The summary information from all samples is merged. A fasta file of candidate fusions from all samples is created.

If everything runs smoothly, you should see two new files created in your working directory: `jaffa_results.csv` and `jaffa_results.fasta`. See OutputDescription for a description of the content of these files.


= JAFFA - Direct =

To run the direct mode, do:
{{{
bpipe run -p output_name="jaffa_results_direct" <JAFFA dir>/JAFFA_no_assembly.groovy <data dir>/BT-474_small_*.fastq.gz <data dir>/MCF-7_small_*.fastq.gz
}}}
Note here that I haven't specified the read lengths. This is parameter is not used here. Also see that I've specified a different output filename prefix (so that we don't overwrite the previous jaffa_results files we created from the assembly mode.

You'll see a few different stages in this pipeline, compared to the previous:
  # _*Stage cat_reads*_ . Concatenate the paired-end reads into a single file.
  # _*Stage remove_dup*_ . Remove duplicate reads.
  # _*Stage get_unmapped*_. Map the reads to the reference transcriptome and extract the reads that do not map.


= JAFFA - Hybrid =

Hybrid give you the best of both assembly and direct. Run it like so:
{{{
bpipe run -p output_name="jaffa_results_hybrid" -p read_length=76 <JAFFA dir>/JAFFA_hybrid.groovy <data dir>/BT-474_small_*.fastq.gz <data dir>/MCF-7_small_*.fastq.gz
}}}