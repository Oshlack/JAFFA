#summary Common questions and issues will be posted here

= FAQ =

* How can I use a genome other than hg19?

Download the relevant reference files from [Download], then follow the installation instruction as you would for hg19. You can then either:
  * Edit the `genome` and `annotation` fields in JAFFA_stages.groovy, or
  * Provide the same details during run time with the bpipe options `-p genome=<genome> -p annotation=genCode<version>`
Here is an example for mouse:
{{{
bpipe run -p genome=mm10 -p annotation=genCodeVM4 <path to JAFFA>/JAFFA_direct.groovy <fastq.gz files>
}}}

If you have a favourite genome that is currently not supported write us an email and we'll looking into either providing the reference files, or instruction on how to generate them yourself.


* How long will it take to run and how much RAM is needed?

This will depend a lot on the depth of data (e.g. the number of bases sequenced) and on which JAFFA mode was run. The Direct mode is the least computationally expensive. Assembly and Hybrid modes can use much more memory and require longer to run because of the de novo assembly step. 

Some examples of the range to expect (based on datasets we've run on):

Direct mode on 100bp paired-end reads
  * Reads: 2.5-40 million 
  * RAM: Always less than 10 GB
  * Time: 1.5-40 CPU hours

Assembly mode on 50bp paired-end reads
  * Reads: 14-42 million
  * RAM: 5.5-18 Gb
  * Time: 2.5-6 hours

Hybrid mode on 100bp paired-end reads
  * Reads: 2.5-40 million 
  * RAM: 4-75 GB
  * Time: 4-60 CPU hours

* How to view the read coverage over a fusion transcript in IGV 

  # From the file, jaffa_results.csv, determine the "sample", "contig" and "contig break" of the fusion of interest. The contig must start with "Locus..", i.e. be an Oases assembled contig (and not a read ID).
  # Load IGV
  # In IGV click on "Load Genome from File" and then navigate to the directory called `<sample`>. Click on the file `<sample>`.fusions.fa
  # In the drop-down box which usually contains the chromosome names (or using the text box next to it, put in the name of `<contig>`)
  # Load the reads by clicking "Load from File". In the directory `<sample`>, select the file named `<sample`>.sorted.bam
  # To highlight the breakpoint, go to "Regions", "Regions Navigator" and put in `<contig break`> as the start and `<contig break`> +1 as the end. Then click "View".

= Troubleshooting =

* BLAT fails with error: _Internal error genoFind.c 2250_ *

Check the tile size limit of the version of BLAT you have installed. JAFFA assumes a tile size up to 18, but some version of BLAT (e.g. v. 35) do not support tile sizes this large. You can get around this easily by running with the option "-p contigTile=X -p readTile=X" replacing X with the maximum supported tile size. The tile size does not impact on the accuracy of results in most cases, but a larger size will make the alignment steps faster.

* JAFFA is not properly parallelising the samples or you get an error like `"`The pattern provided `%_*`.fastq.gz did not match any of the files provided as input `[`checks`]"`*

You may need to change the value of the variable `fastqInputFormat` which is set to `%_*`.fastq.gz by default. What this does is to search for files of the form `%_*`.fastq.gz in your input list. Both the `%` and `*` are wildcards (like the `'*'` in bash). However bpipe will parallelise based on differences in the `%` part of the name. For example, if these are your files:

{{{ sampleA_R1.fastq.gz, sampleA_R2.fastq.gz, sampleB_R1.fastq.gz, sampleB_R2.fastq.gz }}}

The `%` parts are sampleA and sampleB, so bpipe will start two parallel jobs going. 
Sometimes you can run into trouble with the default pattern if either the extension (fastq.gz) is different, if there are multiple `"_"`s, or no `"_"`s. You may need to change the pattern to fit your case. As an example, lets say your files are called:

{{{ A_1_1.fq.gz, A_1_R2.fq.gz, B_1_R1.fq.gz, B_1_R2.fq.gz }}}

Then you should run bpipe like this:

{{{ bpipe run -p fastqInputFormat="%_1_*.fq.gz" }}}
 